{"version":3,"file":"network-connector.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import { ConnectorUpdate } from '@web3-react/types'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport invariant from 'tiny-invariant'\n\ninterface NetworkConnectorArguments {\n  urls: { [chainId: number]: string }\n  defaultChainId?: number\n}\n\n// taken from ethers.js, compatible interface with web3 provider\ntype AsyncSendable = {\n  isMetaMask?: boolean\n  host?: string\n  path?: string\n  sendAsync?: (request: any, callback: (error: any, response: any) => void) => void\n  send?: (request: any, callback: (error: any, response: any) => void) => void\n}\n\nclass RequestError extends Error {\n  constructor(message: string, public code: number, public data?: unknown) {\n    super(message)\n  }\n}\n\nclass MiniRpcProvider implements AsyncSendable {\n  public readonly isMetaMask: false = false\n  public readonly chainId: number\n  public readonly url: string\n  public readonly host: string\n  public readonly path: string\n\n  constructor(chainId: number, url: string) {\n    this.chainId = chainId\n    this.url = url\n    const parsed = new URL(url)\n    this.host = parsed.host\n    this.path = parsed.pathname\n  }\n\n  public readonly sendAsync = (\n    request: { jsonrpc: '2.0'; id: number | string | null; method: string; params?: unknown[] | object },\n    callback: (error: any, response: any) => void\n  ): void => {\n    this.request(request.method, request.params)\n      .then(result => callback(null, { jsonrpc: '2.0', id: request.id, result }))\n      .catch(error => callback(error, null))\n  }\n\n  public readonly request = async (method: string, params?: unknown[] | object): Promise<unknown> => {\n    const response = await fetch(this.url, {\n      method: 'POST',\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: 1,\n        method,\n        params\n      })\n    })\n    if (!response.ok) throw new RequestError(`${response.status}: ${response.statusText}`, -32000)\n    const body = await response.json()\n    if ('error' in body) {\n      throw new RequestError(body?.error?.message, body?.error?.code, body?.error?.data)\n    } else if ('result' in body) {\n      return body.result\n    } else {\n      throw new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, body)\n    }\n  }\n}\n\nexport class NetworkConnector extends AbstractConnector {\n  private readonly providers: { [chainId: number]: MiniRpcProvider }\n  private currentChainId: number\n\n  constructor({ urls, defaultChainId }: NetworkConnectorArguments) {\n    invariant(defaultChainId || Object.keys(urls).length === 1, 'defaultChainId is a required argument with >1 url')\n    super({ supportedChainIds: Object.keys(urls).map((k): number => Number(k)) })\n\n    this.currentChainId = defaultChainId || Number(Object.keys(urls)[0])\n    this.providers = Object.keys(urls).reduce<{ [chainId: number]: MiniRpcProvider }>((accumulator, chainId) => {\n      accumulator[Number(chainId)] = new MiniRpcProvider(Number(chainId), urls[Number(chainId)])\n      return accumulator\n    }, {})\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    return { provider: this.providers[this.currentChainId], chainId: this.currentChainId, account: null }\n  }\n\n  public async getProvider(): Promise<MiniRpcProvider> {\n    return this.providers[this.currentChainId]\n  }\n\n  public async getChainId(): Promise<number> {\n    return this.currentChainId\n  }\n\n  public async getAccount(): Promise<null> {\n    return null\n  }\n\n  public deactivate() {\n    return\n  }\n}\n"],"names":["RequestError","message","code","data","Error","MiniRpcProvider","chainId","url","this","request","callback","_this2","method","params","then","result","jsonrpc","id","error","fetch","_this3","body","JSON","stringify","response","ok","status","statusText","json","_body$error","_body$error2","_body$error3","parsed","URL","host","path","pathname","urls","defaultChainId","Object","keys","length","invariant","supportedChainIds","map","k","Number","currentChainId","providers","reduce","accumulator","activate","provider","account","getProvider","getChainId","getAccount","deactivate","AbstractConnector"],"mappings":"u2CAkBMA,yBACQC,EAAwBC,EAAqBC,8BACjDF,eAD4BC,SAAqBC,uBADhCC,QAMrBC,EAOJ,SAAYC,EAAiBC,SAkBEC,6BAxBK,iBAcR,SAC1BC,EACAC,GAEAC,EAAKF,QAAQA,EAAQG,OAAQH,EAAQI,QAClCC,MAAK,SAAAC,UAAUL,EAAS,KAAM,CAAEM,QAAS,MAAOC,GAAIR,EAAQQ,GAAIF,OAAAA,cAC1D,SAAAG,UAASR,EAASQ,EAAO,gCAGHN,EAAgBC,8BACxBM,MAAMC,EAAKb,IAAK,CACrCK,OAAQ,OACRS,KAAMC,KAAKC,UAAU,CACnBP,QAAS,MACTC,GAAI,EACJL,OAAAA,EACAC,OAAAA,sBANEW,OASDA,EAASC,GAAI,MAAM,IAAIzB,EAAgBwB,EAASE,YAAWF,EAASG,YAAe,6BACrEH,EAASI,uBAAtBP,gBACF,UAAWA,QACP,IAAIrB,QAAaqB,YAAAA,EAAMH,cAANW,EAAa5B,cAASoB,YAAAA,EAAMH,cAANY,EAAa5B,WAAMmB,YAAAA,EAAMH,cAANa,EAAa5B,MACxE,GAAI,WAAYkB,SACdA,EAAKN,aAEN,IAAIf,8CAAyDY,eAAoB,KAAOS,kDAjC3Ff,QAAUA,OACVC,IAAMA,MACLyB,EAAS,IAAIC,IAAI1B,QAClB2B,KAAOF,EAAOE,UACdC,KAAOH,EAAOI,mEAsCPC,IAAAA,KAAMC,IAAAA,sBACRA,GAA+C,IAA7BC,OAAOC,KAAKH,GAAMI,QAA9CC,qBACM,CAAEC,kBAAmBJ,OAAOC,KAAKH,GAAMO,KAAI,SAACC,UAAcC,OAAOD,eAElEE,eAAiBT,GAAkBQ,OAAOP,OAAOC,KAAKH,GAAM,MAC5DW,UAAYT,OAAOC,KAAKH,GAAMY,QAA+C,SAACC,EAAa5C,UAC9F4C,EAAYJ,OAAOxC,IAAY,IAAID,EAAgByC,OAAOxC,GAAU+B,EAAKS,OAAOxC,KACzE4C,IACN,wCAGQC,+CACJ,CAAEC,SAAU5C,KAAKwC,UAALxC,KAAoBuC,gBAAiBzC,QAArCE,KAAmDuC,eAAgBM,QAAS,6CAGpFC,kDACJ9C,KAAKwC,UAALxC,KAAoBuC,uDAGhBQ,iDACJ/C,KAAKuC,sDAGDS,6CACJ,SAGFC,WAAA,gBA/B6BC"}